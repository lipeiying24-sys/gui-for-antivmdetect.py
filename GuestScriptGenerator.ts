import { ConfigData, SecurityData, RegionConfigData } from './types';

export const generateGuestScript = (
  config: ConfigData,
  security: SecurityData,
  regionConfig: RegionConfigData
): string => {
  const now = new Date().toLocaleString();
  
  // Fix Bug 2: Dynamic CPU Identifier based on Vendor
  let cpuId = "Intel64 Family 6 Model 158 Stepping 10"; // Default Intel
  if (config.DmiProcManufacturer.toLowerCase().includes("amd")) {
      cpuId = "AMD64 Family 23 Model 1 Stepping 1"; // Default AMD Ryzen
  }
  
  // Fix Bug 1: ProductId Formatting safely constructed outside template
  // Fix Bug 2: LanguageList needs to be array format in PowerShell
  const langListCmd = `Set-WinUserLanguageList -LanguageList (${regionConfig.LanguageList.split(',').map(l => `"${l.trim()}"`).join(',')}) -Force`;

  return `# AntiVM Guest Script - Generated by AntiVM WebGUI
# Run this INSIDE the Virtual Machine (PowerShell Administrator)
# Generated at ${now}

Write-Host "Starting Anti-VM Configuration..." -ForegroundColor Cyan

# --- HELPER: Registry Permission Granter (Enhancement C) ---
function Grant-RegistryOwnership {
    param ( [string]$Key )
    Write-Host " -> Granting ownership for: $Key" -ForegroundColor DarkGray
    $path = "HKLM:\\$Key"
    if (!(Test-Path $path)) { return }
    
    try {
        $acl = Get-Acl $path
        # Best effort attempt to grant Admin rights. 
        # Note: Modifying some SYSTEM keys requires TrustedInstaller, which PS cannot easily impersonate without tools.
        # However, taking ownership as Admin usually works for HKLM hardware keys.
        $rule = New-Object System.Security.AccessControl.RegistryAccessRule ("Administrators","FullControl","Allow")
        $acl.SetOwner([System.Security.Principal.NTAccount]"Administrators")
        $acl.SetAccessRule($rule)
        Set-Acl $path $acl
    } catch {
        Write-Warning "Failed to grant permission on $Key. Attempting generic write anyway. ($($_.Exception.Message))"
    }
}

# --- 1. Registry Spoofing (Hardened) ---
Write-Host "[-] Spoofing Registry Hardware Keys..."

# 1.1 BIOS & System
$RegBios = "HKLM:\\HARDWARE\\DESCRIPTION\\System\\BIOS"
$RegSys = "HKLM:\\HARDWARE\\DESCRIPTION\\System"

if (!(Test-Path $RegBios)) { New-Item -Path $RegBios -Force | Out-Null }
if (!(Test-Path $RegSys)) { New-Item -Path $RegSys -Force | Out-Null }

$biosProps = @{
    "SystemBiosVersion" = "${config.DmiBIOSVendor} - ${config.DmiBIOSVersion}";
    "VideoBiosVersion" = "${config.DmiBIOSVersion}";
    "SystemBiosDate" = "${config.DmiBIOSReleaseDate}";
    "BaseBoardManufacturer" = "${config.DmiBoardVendor}";
    "BaseBoardProduct" = "${config.DmiBoardProduct}";
    "SystemManufacturer" = "${config.DmiSystemVendor}";
    "SystemProductName" = "${config.DmiSystemProduct}";
}

foreach ($key in @($RegBios, $RegSys)) {
    foreach ($prop in $biosProps.Keys) {
        Set-ItemProperty -Path $key -Name $prop -Value $biosProps[$prop] -Force
    }
}

# 1.2 CPU (CentralProcessor) - Fix Bug 2: Dynamic ID
$RegCpuRoot = "HKLM:\\HARDWARE\\DESCRIPTION\\System\\CentralProcessor"
if (Test-Path $RegCpuRoot) {
    $cpus = Get-ChildItem -Path $RegCpuRoot
    foreach ($cpu in $cpus) {
        Set-ItemProperty -Path $cpu.PSPath -Name "ProcessorNameString" -Value "${config.DmiProcVersion}" -Force
        Set-ItemProperty -Path $cpu.PSPath -Name "Identifier" -Value "${cpuId}" -Force
        Set-ItemProperty -Path $cpu.PSPath -Name "VendorIdentifier" -Value "${config.DmiProcManufacturer}" -Force
    }
}

# 1.3 Disk Enum Spoofing (Fix Bug 3: Permissions, Fix Bug 4: Property Check)
Write-Host "[-] Spoofing Disk Enum (Deep)..."
$EnumScsi = "SYSTEM\\CurrentControlSet\\Enum\\SCSI"
Grant-RegistryOwnership $EnumScsi

# Iterate over SCSI Enum to find disks and mask them
$scsiRoot = "HKLM:\\$EnumScsi"
if (Test-Path $scsiRoot) {
    Get-ChildItem $scsiRoot -Recurse | ForEach-Object {
        # Fix Bug 4: Robust property check using PSObject.Properties
        if ($_.PSObject.Properties.Match('FriendlyName').Count -gt 0) {
            $keyPath = $_.PSPath
            Set-ItemProperty -Path $keyPath -Name "FriendlyName" -Value "${config.DiskModelNumber}" -Force -ErrorAction SilentlyContinue
            Set-ItemProperty -Path $keyPath -Name "HardwareID" -Value @("SCSI\\Disk${config.DiskModelNumber}") -Force -ErrorAction SilentlyContinue
        }
    }
}

# 1.4 MountedDevices Spoofing (Fix Bug 5)
Write-Host "[-] Spoofing MountedDevices..."
$MountDev = "SYSTEM\\MountedDevices"
Grant-RegistryOwnership $MountDev
$MountPath = "HKLM:\\$MountDev"

if (Test-Path $MountPath) {
    # Generate a fake signature (MBR signature style - 4 bytes)
    $randSig = New-Object Byte[] 4; (New-Object Random).NextBytes($randSig)
    
    # Try to spoof DOS devices if they exist (Cautious approach to avoid boot loop)
    # We only change the signature part of the binary blob if we can identify it, 
    # but for safety in this script, we'll try to update specific known keys if feasible.
    # Note: Full MountedDevices spoofing is dangerous in pure PS without parsing structures.
    # We will simply touch the key to ensure it exists and maybe add a fake entry to dilute.
    
    # Adding a dummy history entry to confuse simplistic enumerators
    Set-ItemProperty -Path $MountPath -Name "\\DosDevices\\Z:" -Value $randSig -Force -ErrorAction SilentlyContinue
}

# --- 2. Randomize Product IDs (Fix Bug 1: Formatting) ---
${security.randomizeProductIds ? `
Write-Host "[-] Randomizing ProductId..."
$RegNT = "HKLM:\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion"
if (Test-Path $RegNT) {
    $chars = "BCDFGHJKMPQRTVWXY2346789"
    $pidStr = ""
    for ($i=0; $i -lt 5; $i++) {
        $segment = ""
        for ($j=0; $j -lt 5; $j++) { 
            $idx = (Get-Random -Max $chars.Length)
            $segment += $chars[$idx] 
        }
        $pidStr += $segment
        if ($i -lt 4) { $pidStr += "-" }
    }
    Set-ItemProperty -Path $RegNT -Name "ProductId" -Value $pidStr -Force
}
` : '# ProductID Randomization skipped'}

# --- 3. Fake Files Generator (Fix Bug 3: PNG Header, Fix Bug 6: Better Fakes) ---
${security.generateFakeFiles ? `
Write-Host "[-] Generating Fake User Activity (Complex)..."
$dirs = @("Desktop", "MyDocuments", "MyPictures", "Recent")
foreach ($d in $dirs) {
    $path = [Environment]::GetFolderPath($d)
    
    # Generate Text Files
    for ($i=0; $i -lt 3; $i++) {
        $name = [System.IO.Path]::GetRandomFileName().Split(".")[0]
        $content = "Project Data " + [Guid]::NewGuid().ToString()
        Set-Content -Path "$path\\$name.txt" -Value $content
    }

    # Generate Fake PNG (Binary)
    for ($i=0; $i -lt 2; $i++) {
        $name = [System.IO.Path]::GetRandomFileName().Split(".")[0]
        $pngPath = "$path\\$name.png"
        $bytes = New-Object Byte[] 1024
        (New-Object Random).NextBytes($bytes)
        # Fix Bug 3: Full PNG Header (8 bytes)
        $bytes[0]=0x89; $bytes[1]=0x50; $bytes[2]=0x4E; $bytes[3]=0x47; 
        $bytes[4]=0x0D; $bytes[5]=0x0A; $bytes[6]=0x1A; $bytes[7]=0x0A;
        [System.IO.File]::WriteAllBytes($pngPath, $bytes)
    }
}
# Fake Browser Cache Structure
$cachePath = "$env:LOCALAPPDATA\\Google\\Chrome\\User Data\\Default\\Cache"
if (!(Test-Path $cachePath)) { New-Item -Path $cachePath -ItemType Directory -Force | Out-Null }
` : '# Fake file generation skipped'}

# --- 4. Honeytokens ---
${security.injectHoneytokens ? `
Write-Host "[-] Injecting Randomized Honeytokens..."
$tokens = @(
    "AWS_ACCESS_KEY_ID=AKIA" + [Guid]::NewGuid().ToString().Replace("-","").Substring(0,16),
    "ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC" + [Guid]::NewGuid().ToString(),
    "{""auth_token"": """ + [Guid]::NewGuid().ToString() + """}"
)
$t = $tokens | Get-Random
Set-Clipboard -Value $t
` : '# Honeytokens skipped'}

# --- 5. VBox Cleanup ---
${security.removeVBoxFiles ? `
Write-Host "[-] Removing VirtualBox Artifacts..."
$Drivers = @("VBoxMouse.sys", "VBoxGuest.sys", "VBoxSF.sys", "VBoxVideo.sys")
foreach ($drv in $Drivers) {
    $path = "C:\\Windows\\System32\\drivers\\$drv"
    if (Test-Path $path) { Remove-Item $path -Force -ErrorAction SilentlyContinue }
}
` : '# VBox Cleanup skipped'}

# --- 6. VolumeID Randomization ---
${security.randomizeVolumeId ? `
Write-Host "[-] Checking for VolumeID..."
$sys32 = [Environment]::GetFolderPath("System")
$volIdExe = Join-Path $sys32 "Volumeid.exe"

if (Test-Path $volIdExe) {
    $randHex = -join ((0..7) | % { "{0:X}" -f (Get-Random -Min 0 -Max 16) })
    $vPart1 = $randHex.Substring(0,4)
    $vPart2 = $randHex.Substring(4,4)
    Write-Host "[-] Executing VolumeID C: $vPart1-$vPart2"
    Start-Process -FilePath $volIdExe -ArgumentList "C: $vPart1-$vPart2" -Wait -NoNewWindow
} else {
    Write-Warning "Volumeid.exe not found in System32. Please download Sysinternals Suite."
}
` : '# VolumeID Randomization skipped'}

# --- 7. Region (Guest Environment) ---
# Fix Bug 2: Correct array syntax for LanguageList
Write-Host "[-] Setting Region: ${regionConfig.RegionLocale}..."
try {
    Set-WinSystemLocale -SystemLocale "${regionConfig.RegionLocale}"
    Set-TimeZone -Id "${regionConfig.TimeZone}"
    ${langListCmd}
    Set-WinHomeLocation -GeoId ${regionConfig.GeoID}
} catch {
    Write-Warning "Some region settings failed. Ensure you are running as Admin."
}

Write-Host "[+] Configuration Complete. Please REBOOT." -ForegroundColor Green
Start-Sleep -Seconds 3
`;
};