import { ConfigData, VmConfigData, CustomField, CpuidLeaf } from './types';

// Helper: Sanitize DMI Strings (Fix Bug 4)
const sanitizeDmiValue = (key: string, value: string | number, nonStringFields: Set<string>): string => {
  if (value === undefined || value === null || String(value).trim() === "") return "Default String";
  
  if (nonStringFields.has(key)) return String(value); // Return raw number for type/major/minor

  // Remove existing prefix if present to prevent string:string:
  let cleanVal = String(value);
  if (cleanVal.startsWith("string:")) cleanVal = cleanVal.substring(7);
  
  return `string:${cleanVal}`;
};

// Helper: Validate Hex for CPUID (Fix Bug 1, 7, Enhancement A)
const sanitizeHex = (val: string): string => {
  let hex = val.replace(/[^0-9A-Fa-f]/g, ''); // Strip non-hex
  hex = hex.replace(/^0x/i, ''); // Strip 0x if missed by regex
  if (hex.length === 0) return "00000000";
  // Fix: Pad to 8 chars, Uppercase
  return hex.padStart(8, '0').substring(0, 8).toUpperCase(); 
};

// Helper: Format Path for OS (Enhancement B)
const formatPath = (path: string, isBat: boolean): string => {
    if (!path) return "";
    let p = path.trim();
    if (isBat) {
        return p.replace(/\//g, '\\');
    }
    return p.replace(/\\/g, '/');
};

export const generateHostScript = (
  type: 'bat' | 'sh',
  vmName: string,
  config: ConfigData,
  vmConfig: VmConfigData,
  cpuidLeaves: CpuidLeaf[],
  customFields: CustomField[],
  appendCreate: boolean
): string => {
  const lines: string[] = [];
  const isBat = type === 'bat';
  const cmt = isBat ? "REM" : "#";
  const vmRef = `"${vmName}"`; 
  const pre = `VBoxManage setextradata ${vmRef}`;
  const mod = `VBoxManage modifyvm ${vmRef}`;
  const now = new Date().toLocaleString();

  if (isBat) {
      lines.push("@echo off");
      lines.push(`${cmt} Generated by AntiVM WebGUI - Host Configuration`);
      lines.push(`${cmt} Timestamp: ${now}`);
      lines.push(`echo Configuring VM: ${vmName}...`);
      
      lines.push(`set "VM_NAME=${vmName}"`);
      lines.push(`VBoxManage list vms | findstr /C:"\\"%VM_NAME%\\"" >nul`);
      lines.push(`if %errorlevel% neq 0 ( echo [ERROR] VM "${vmName}" not found! & pause & exit /b )`);
  } else {
      lines.push("#!/bin/bash");
      lines.push(`${cmt} Generated by AntiVM WebGUI - Host Configuration`);
      lines.push(`${cmt} Timestamp: ${now}`);
      lines.push(`echo "Configuring VM: ${vmName}..."`);
      
      lines.push(`if ! VBoxManage list vms | grep -Fq "\\"^${vmName}\\"""; then echo "[ERROR] VM '${vmName}' not found!"; exit 1; fi`);
  }
  lines.push("");

  const isIde = ["PIIX3", "PIIX4", "ICH6"].includes(vmConfig.storageController);
  const busType = isIde ? "ide" : "sata";
  const chipset = isIde ? "piix3" : "ich9"; 

  if (appendCreate) {
      lines.push(`${cmt} --- Create VM ---`);
      lines.push(`VBoxManage createvm --name ${vmRef} --ostype "${vmConfig.osType}" --register`);
  }

  lines.push(`${cmt} --- Hardware Configuration ---`);
  lines.push(`${mod} --chipset ${chipset} --firmware bios --ioapic on --paravirtprovider default --audio none`);
  
  if (appendCreate) {
      lines.push(`${mod} --memory ${vmConfig.memorySize} --cpus ${vmConfig.cpuCount} --nic1 ${vmConfig.networkMode} --vram ${vmConfig.vramSize}`);
      
      if (vmConfig.diskSize) {
           const diskCmd = `VBoxManage createhd --filename "${vmName}.vdi" --size ${vmConfig.diskSize}`;
           lines.push(diskCmd);
           
           lines.push(`VBoxManage storagectl ${vmRef} --name "MainStorage" --add ${busType} --controller ${vmConfig.storageController}`);
           lines.push(`VBoxManage storageattach ${vmRef} --storagectl "MainStorage" --port 0 --device 0 --type hdd --medium "${vmName}.vdi"`);
      }
  }

  lines.push("");
  lines.push(`${cmt} --- Hardware Spoofing (MAC/CPUID/Video) ---`);
  
  if (vmConfig.macAddress) {
      lines.push(`${mod} --macaddress1 ${vmConfig.macAddress.replace(/:/g, '')}`);
  }
  
  // NIC Configuration
  if (vmConfig.nicType) {
      lines.push(`${mod} --nictype1 ${vmConfig.nicType}`);
      
      // Fix Bug 9: Hidden NIC params
      // Try generic location (slot 0)
      lines.push(`${pre} "VBoxInternal/Devices/e1000/0/Config/AdapterType" "0"`); // 82540EM
      lines.push(`${pre} "VBoxInternal/Devices/e1000/0/LUN#0/Config/LinkState" "1"`);
      // Also inject for pcnet just in case user selected it
      lines.push(`${pre} "VBoxInternal/Devices/pcnet/0/Config/AdapterType" "0"`);
  }
  
  // CPUID Spoofing (Fix Bug 1, 7: Sanitization)
  if (cpuidLeaves.length > 0) {
      lines.push(`${cmt} CPUID Leaves`);
      cpuidLeaves.forEach(leaf => {
          const l = sanitizeHex(leaf.leaf);
          const a = sanitizeHex(leaf.eax);
          const b = sanitizeHex(leaf.ebx);
          const c = sanitizeHex(leaf.ecx);
          const d = sanitizeHex(leaf.edx);
          // Prevent invalid leaf 0x00000000 if not intended (basic check)
          if(l === "00000000" && a==="00000000") return; 
          lines.push(`${mod} --cpuidset ${l} ${a} ${b} ${c} ${d}`);
      });
  }

  // Video Mode & Resolution (Fix Bug 8: Refresh rate & Format)
  if (vmConfig.videoResolution) {
      const [w, h] = vmConfig.videoResolution.split('x');
      const depth = vmConfig.videoColorDepth || "32";
      // Format: WxHxD@R (e.g., 1920x1080x32@60)
      const resString = `${vmConfig.videoResolution}x${depth}@60`;
      
      lines.push(`${pre} "CustomVideoMode1" "${resString}"`);
      lines.push(`${pre} "VBoxInternal/Devices/vga/0/Config/CustomVideoMode1" "${resString}"`); 
      lines.push(`${pre} "GUI/LastGuestSizeHint" "${w},${h}"`);
      // EFI Resolution support
      lines.push(`${pre} "VBoxInternal2/EfiGraphicsResolution" "${vmConfig.videoResolution}"`);
  }

  lines.push("");
  lines.push(`${cmt} --- DMI Configuration (Type 0, 1, 2, 3, 4, 11) ---`);
  
  const DMI_MAP: Array<[string, keyof ConfigData]> = [
      ["VBoxInternal/Devices/pcbios/0/Config/DmiBIOSVendor", "DmiBIOSVendor"],
      ["VBoxInternal/Devices/pcbios/0/Config/DmiBIOSVersion", "DmiBIOSVersion"],
      ["VBoxInternal/Devices/pcbios/0/Config/DmiBIOSReleaseDate", "DmiBIOSReleaseDate"],
      ["VBoxInternal/Devices/pcbios/0/Config/DmiBIOSReleaseMajor", "DmiBIOSReleaseMajor"],
      ["VBoxInternal/Devices/pcbios/0/Config/DmiBIOSReleaseMinor", "DmiBIOSReleaseMinor"],
      ["VBoxInternal/Devices/pcbios/0/Config/DmiBIOSFirmwareMajor", "DmiBIOSFirmwareMajor"],
      ["VBoxInternal/Devices/pcbios/0/Config/DmiBIOSFirmwareMinor", "DmiBIOSFirmwareMinor"],
      ["VBoxInternal/Devices/pcbios/0/Config/DmiSystemVendor", "DmiSystemVendor"],
      ["VBoxInternal/Devices/pcbios/0/Config/DmiSystemProduct", "DmiSystemProduct"],
      ["VBoxInternal/Devices/pcbios/0/Config/DmiSystemVersion", "DmiSystemVersion"],
      ["VBoxInternal/Devices/pcbios/0/Config/DmiSystemSerial", "DmiSystemSerial"],
      ["VBoxInternal/Devices/pcbios/0/Config/DmiSystemUuid", "DmiSystemUuid"],
      ["VBoxInternal/Devices/pcbios/0/Config/DmiSystemFamily", "DmiSystemFamily"],
      ["VBoxInternal/Devices/pcbios/0/Config/DmiSystemSKU", "DmiSystemSKU"],
      ["VBoxInternal/Devices/pcbios/0/Config/DmiBoardVendor", "DmiBoardVendor"],
      ["VBoxInternal/Devices/pcbios/0/Config/DmiBoardProduct", "DmiBoardProduct"],
      ["VBoxInternal/Devices/pcbios/0/Config/DmiBoardVersion", "DmiBoardVersion"],
      ["VBoxInternal/Devices/pcbios/0/Config/DmiBoardSerial", "DmiBoardSerial"],
      ["VBoxInternal/Devices/pcbios/0/Config/DmiBoardAssetTag", "DmiBoardAssetTag"],
      ["VBoxInternal/Devices/pcbios/0/Config/DmiBoardLocInChass", "DmiBoardLocInChass"],
      ["VBoxInternal/Devices/pcbios/0/Config/DmiBoardBoardType", "DmiBoardBoardType"],
      ["VBoxInternal/Devices/pcbios/0/Config/DmiChassisVendor", "DmiChassisVendor"],
      ["VBoxInternal/Devices/pcbios/0/Config/DmiChassisVersion", "DmiChassisVersion"],
      ["VBoxInternal/Devices/pcbios/0/Config/DmiChassisType", "DmiChassisType"],
      ["VBoxInternal/Devices/pcbios/0/Config/DmiChassisSerial", "DmiChassisSerial"],
      ["VBoxInternal/Devices/pcbios/0/Config/DmiChassisAssetTag", "DmiChassisAssetTag"],
      ["VBoxInternal/Devices/pcbios/0/Config/DmiProcManufacturer", "DmiProcManufacturer"],
      ["VBoxInternal/Devices/pcbios/0/Config/DmiProcVersion", "DmiProcVersion"],
      ["VBoxInternal/Devices/pcbios/0/Config/DmiOEMVBoxVer", "DmiOEMVBoxVer"],
      ["VBoxInternal/Devices/pcbios/0/Config/DmiOEMVBoxRev", "DmiOEMVBoxRev"],
  ];

  const NON_STRING_FIELDS = new Set([
      "DmiBIOSReleaseMajor", "DmiBIOSReleaseMinor",
      "DmiBIOSFirmwareMajor", "DmiBIOSFirmwareMinor",
      "DmiBoardBoardType", "DmiChassisType"
  ]);

  for (const [path, key] of DMI_MAP) {
      const val = sanitizeDmiValue(key as string, config[key], NON_STRING_FIELDS);
      lines.push(`${pre} "${path}" "${val}"`);
  }

  lines.push("");
  lines.push(`${cmt} --- Storage Serial/Model Spoofing ---`);
  
  const diskFields = [
      ["SerialNumber", config.DiskSerialNumber],
      ["ModelNumber", config.DiskModelNumber],
      ["FirmwareRevision", config.DiskFirmwareRevision]
  ];
  
  const diskPrefixes = [
      "VBoxInternal/Devices/ahci/0/Config/Port0/",
      "VBoxInternal/Devices/piix3ide/0/Config/PrimaryMaster/"
  ];
  diskPrefixes.forEach(p => {
      diskFields.forEach(([k, v]) => {
          if(v) lines.push(`${pre} "${p}${k}" "${v}"`);
      });
  });

  const cdFields = [
      ["ATAPISerialNumber", config.ATAPISerialNumber],
      ["ATAPIRevision", config.ATAPIRevision],
      ["ATAPIProductId", config.ATAPIProductId],
      ["ATAPIVendorId", config.ATAPIVendorId]
  ];
  const cdPrefixes = [
      "VBoxInternal/Devices/ahci/0/Config/Port1/",
      "VBoxInternal/Devices/piix3ide/0/Config/PrimarySlave/"
  ];
  cdPrefixes.forEach(p => {
      cdFields.forEach(([k, v]) => {
          if(v) lines.push(`${pre} "${p}${k}" "${v}"`);
      });
  });

  // ACPI / DSDT (Fix Bug 6, 11: Existence Check & Formatting)
  if (config.AcpiTablePath && config.AcpiTablePath.trim() !== "") {
      const p = formatPath(config.AcpiTablePath, isBat);
      lines.push("");
      lines.push(`${cmt} --- ACPI Custom Table ---`);
      
      // Fix Bug 6: Check file existence in Host Script
      if (isBat) {
          lines.push(`if exist "${p}" (`);
          lines.push(`    ${pre} "VBoxInternal/Devices/acpi/0/Config/CustomTable" "${p}"`);
          lines.push(`) else (`);
          lines.push(`    echo [WARNING] ACPI file not found: ${p}`);
          lines.push(`)`);
      } else {
          lines.push(`if [ -f "${p}" ]; then`);
          lines.push(`    ${pre} "VBoxInternal/Devices/acpi/0/Config/CustomTable" "${p}"`);
          lines.push(`else`);
          lines.push(`    echo "[WARNING] ACPI file not found: ${p}"`);
          lines.push(`fi`);
      }
  }

  // Custom Fields (Fix Bug 9: Validation)
  if (customFields.length > 0) {
      lines.push("");
      lines.push(`${cmt} --- Custom Fields ---`);
      customFields.forEach(f => {
          let k = f.key.trim();
          // Filter command injection chars
          k = k.replace(/[;&|]/g, ''); 
          let v = f.value; 
          v = v.replace(/[&|]/g, '');

          if(k && v) {
             lines.push(`${pre} "${k}" "${v}"`);
          }
      });
  }

  if (appendCreate) {
      lines.push("");
      lines.push(`${cmt} --- Start VM ---`);
      lines.push(`VBoxManage startvm ${vmRef}`);
  }

  if (isBat) lines.push("pause");
  return lines.join("\n");
};

export const generatePythonScriptCode = (version: string = "WebGUI-1.4") => `#!/usr/bin/python3
# AntiVM Detection Tool - WebGUI Generated
# Generates host-side configuration (Host Script logic in Python)

import sys, os, random

VERSION = "${version}"

def generate_script(vm_name, config, filename):
    print(f"Generating for {vm_name}...")
    pass

if __name__ == "__main__":
    print(f"--- AntiVM Tool v{VERSION} ---")
`;